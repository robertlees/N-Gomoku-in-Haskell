-------------------
-- Update Game with a new "_end" attribute
data Game = Game
  { _board  :: GB.Board -- ^ Gomoku Board
  , _rule   :: Int     -- ^ how many stones in a line will win the game?
  , _winner :: GB.Blockstat  -- ^ winner of the game
  , _player :: GB.Side -- ^ current player
  , _cursor  :: (Int, Int) -- ^ cursor's location
  , _end  :: Bool
  , _socket :: Socket -- ^ network socket
  } deriving (Show)

-- Also include this in UI.hs

handleEvent :: Game -> BrickEvent () e -> EventM () (Next Game)
handleEvent game (VtyEvent (V.EvKey key [])) =
  case key of
    -- Move cursor
    V.KUp       -> continue $ cursorCtrl Up 1 game
    V.KDown     -> continue $ cursorCtrl Down 1 game
    V.KLeft     -> continue $ cursorCtrl Left 1 game
    V.KRight    -> continue $ cursorCtrl Right 1 game

    V.KChar ' ' -> continue $ if (_end game) 
                             then game 
                             else makeMove game
    V.KChar 'c' -> halt game
    _           -> continue game

------------------------------
--Include in another file

data Ctrl = Up | Down | Left | Right deriving (show)

cursorCtrl :: Dir -> Game -> Game
CursorCtrl control game = (\c -> game { cursor = c }) 
    $ case control of
    Game.Up -> (x, bound(y - 1))
    Game.Down -> (x, bound (y + 1))
    Game.Right  -> (bound (x + 1), y)
    Game.Left  -> (bound (x - 1), y)
  where
    (x, y) = _cursor game
    bound n
      | n >= 9    = n - 9                   ---changes this to the size of the board
      | n < 0     = n + 9
      | otherwise = n

switchP :: Game -> Game
switchP game = game {_player = if last == White then Black else White}
                    where last = _player game

--need to write a function that is able to transform cursor to the board

makeMove :: Game -> Game
makeMove = if (checkWin (_rule game)) 
           then game {_end = True}
           else game {_cursor = (x, y), _player = switchP game}               --not finished should be able to call addMove from Board.hs
                                                                              --Note: here player would not switch if the previous move wins the game. Thus, can extract the winner as the current player 


--Try adding this new function but not tested
addMoveToGame :: Game -> Game
addMoveToGame game=
    if _end game
        then game  -- If the game has already ended, do nothing
        else if outOfBoard m n (_boardSize (_board game))
            then game -- If the move is out of bounds, do nothing
            else if isOccupied (_board game) m n
                then game -- If the cell is already occupied, do nothing
                else game {_board = updatedBoard, _player = switchP game, _end = checkWin updatedBoard}
  where
    boardSize = _boardSize (_board game)
    updatedBoard = Mkboard (M.insert (m, n) (Occupied side) (_board game)) boardSize            --include the boardSize in 
    (m,n) = _cursor game


-- This is going to take use the checkWin to update the state
checkWinAndUpdate :: Game -> Game
checkWinAndUpdate game =
    let result = checkWin (_board game) (_rule game)
    in case result of
        (True, "White wins") -> game {_end = True, _winner = Just (Occupied White)}
        (True, "Black wins") -> game {_end = True, _winner = Just (Occupied Black)}
        _                   -> game
